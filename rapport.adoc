=  Polycode
Nils Ponsard <nils.ponsard@etu.umontpellier.fr>
19-10-2022
:reproducible:
:toc:


== 1 Functionnal quarter

=== User stories


== 2 Identification and OIDC

== 3 Microservice communication

=== Environment variables

Each service requires environment variables indicating where to find the other services. 

This can become tedious to setup, these variables could have a default value corresponding to the usual service name in kubernetes.

=== service discovery

When starting the services register to the a server. This server will be able to provide the address of the other services.

Two ways to get the address of the other services:
- every time you need to do a request
- fetch regularly the list of services and store it to use for requests.


SPOF : if the service discovery is down, all services can’t reach eachother, you can still keep the previous adress in cache and update when back up.


== 4 Traceability and logging

=== Fetch the logs

- log everything to stdout or stderr
- use (or create) a log aggregator that reads the output from kube or the platform.


=== central logging server 
Let the services upload to a central server.

THIS IS A SPOF, but the project can run without it, you just won’t be able to troobleshoot errors when this service is down.

== 5 Search engine

=== Concept

See `./sketches/Q5-search/ui.drawio`.

This concept needs a new collection storing the search history of all users, containing the search query and the number of times it has been searched. The index will be on the query field (to search text).

When a user starts to type in the search field, the server will respond with suggestion of queries, matched by the beginning of the text, ordered by the number of times researched.

Selecting a suggestion fills the search field and validates the search.

Once the search is validated, use a fuzzy finding algorithm to search through the content 
TODO : strategy, explain fuzzi finding, find how to in mongo

All types of content (module, content, assignement) will be in a list of results, with the same presentation and the type marked.

Ordering with points :
* 1 point for each matching word in the description
* 2 point for each matching word in the title
* 3 point for each matching word in the tags

Results ordered by points, then by date of creation (default, can be changed to date then points).


=== Implementation

[source,JavaScript]
----
db.blog.createIndex(
   {
     description: "text",
     tags: "text",
     title: "text"
   },
   {
     weights: {
      description: 10,
      title: 20,
      tags: 30
     },
     name: "TextIndex"
   }
 )
----


search  :

[source,JavaScript]
----
db.stores.find(
   { $text: { $search: "rust in 30 days" } },
   { score: { $meta: "textScore" } }
).sort( { score: { $meta: "textScore" } } )
----






== 6 Runner architecture

== 7 Data architecture

== 8 Mobile app

== 9 Microservice security

- HTTPS + certificate exchange (kube secrets).

== 10 UI microservice